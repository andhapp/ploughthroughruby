<!doctype html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Immediate Values &middot; Plough => Ruby
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/assets/favicon.ico">
  <link rel="alternate" type="application/atom+xml" title="Plough => Ruby" href="/atom.xml">

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Immediate Values" />
<meta name="author" content="andhapp" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In a previous post, I have explained that variables are basically passed by values in ruby but since they have a reference to the original object any mutator methods can bascially modify the object itself. However, there are two exceptions to this; Fixnum and Symbol. Both, Fixnum and Symbol, store the values and have no reference to the object. This also applies that there are no mutator methods for Fixnum and Symbol and they are immutable. So, how can we actually prove this fact. Let us do a simple experiment and I think I might have done this before but I do not want you going back and forth between posts so let us just do it again. Run the code snippet and we are going through each step: fixnum_1 = 3 p fixnum_1.object_id fixnum_2 = 3 p fixnum_2.object_id str_1 = &quot;3&quot; p str_1.object_id str_2 = &quot;3&quot; p str_2.object_id You will see that both the fixnum variables have the same object_id where as with str variables they will be different. So, what does that mean? It simply means that two fixnums of same value always represent the same object instance, so instance variables for Fixnum with value 1 are shared across the system. The same is the case with Symbol. Ok. Fine. This makes perfect sense but why should I bother with all this explanation. Well, that is a million dollar question really and the answer to that is “You can’t define singleton methods on Fixnums and Symbols”. What? Why? I know this is confusing but when in doubt think of an example. We previously established that all the fixnum variables with same value are actually pointing to the same object instance. If let us say I want to define a singleton method on one then it would really define the singleton method on that object instance which means all the fixnum variables with same value would really share that new method you have added. Therefore, in order to cut that possibilty out one cannot define singleton methods on Fixnum, and Symbls. Update: I have just realised that true (TrueClass), false (FalseClass) and nil (NilClass) also store the references as immediate values. And, yes there is a TrueClass, FalseClass and NilClass and true, false and nil are singleton instances of these classes." />
<meta property="og:description" content="In a previous post, I have explained that variables are basically passed by values in ruby but since they have a reference to the original object any mutator methods can bascially modify the object itself. However, there are two exceptions to this; Fixnum and Symbol. Both, Fixnum and Symbol, store the values and have no reference to the object. This also applies that there are no mutator methods for Fixnum and Symbol and they are immutable. So, how can we actually prove this fact. Let us do a simple experiment and I think I might have done this before but I do not want you going back and forth between posts so let us just do it again. Run the code snippet and we are going through each step: fixnum_1 = 3 p fixnum_1.object_id fixnum_2 = 3 p fixnum_2.object_id str_1 = &quot;3&quot; p str_1.object_id str_2 = &quot;3&quot; p str_2.object_id You will see that both the fixnum variables have the same object_id where as with str variables they will be different. So, what does that mean? It simply means that two fixnums of same value always represent the same object instance, so instance variables for Fixnum with value 1 are shared across the system. The same is the case with Symbol. Ok. Fine. This makes perfect sense but why should I bother with all this explanation. Well, that is a million dollar question really and the answer to that is “You can’t define singleton methods on Fixnums and Symbols”. What? Why? I know this is confusing but when in doubt think of an example. We previously established that all the fixnum variables with same value are actually pointing to the same object instance. If let us say I want to define a singleton method on one then it would really define the singleton method on that object instance which means all the fixnum variables with same value would really share that new method you have added. Therefore, in order to cut that possibilty out one cannot define singleton methods on Fixnum, and Symbls. Update: I have just realised that true (TrueClass), false (FalseClass) and nil (NilClass) also store the references as immediate values. And, yes there is a TrueClass, FalseClass and NilClass and true, false and nil are singleton instances of these classes." />
<link rel="canonical" href="http://localhost:4000/2009/10/31/immediate-values/" />
<meta property="og:url" content="http://localhost:4000/2009/10/31/immediate-values/" />
<meta property="og:site_name" content="Plough =&gt; Ruby" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2009-10-31T00:00:00+00:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2009/10/31/immediate-values/","@type":"BlogPosting","headline":"Immediate Values","dateModified":"2009-10-31T00:00:00+00:00","datePublished":"2009-10-31T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2009/10/31/immediate-values/"},"author":{"@type":"Person","name":"andhapp"},"description":"In a previous post, I have explained that variables are basically passed by values in ruby but since they have a reference to the original object any mutator methods can bascially modify the object itself. However, there are two exceptions to this; Fixnum and Symbol. Both, Fixnum and Symbol, store the values and have no reference to the object. This also applies that there are no mutator methods for Fixnum and Symbol and they are immutable. So, how can we actually prove this fact. Let us do a simple experiment and I think I might have done this before but I do not want you going back and forth between posts so let us just do it again. Run the code snippet and we are going through each step: fixnum_1 = 3 p fixnum_1.object_id fixnum_2 = 3 p fixnum_2.object_id str_1 = &quot;3&quot; p str_1.object_id str_2 = &quot;3&quot; p str_2.object_id You will see that both the fixnum variables have the same object_id where as with str variables they will be different. So, what does that mean? It simply means that two fixnums of same value always represent the same object instance, so instance variables for Fixnum with value 1 are shared across the system. The same is the case with Symbol. Ok. Fine. This makes perfect sense but why should I bother with all this explanation. Well, that is a million dollar question really and the answer to that is “You can’t define singleton methods on Fixnums and Symbols”. What? Why? I know this is confusing but when in doubt think of an example. We previously established that all the fixnum variables with same value are actually pointing to the same object instance. If let us say I want to define a singleton method on one then it would really define the singleton method on that object instance which means all the fixnum variables with same value would really share that new method you have added. Therefore, in order to cut that possibilty out one cannot define singleton methods on Fixnum, and Symbls. Update: I have just realised that true (TrueClass), false (FalseClass) and nil (NilClass) also store the references as immediate values. And, yes there is a TrueClass, FalseClass and NilClass and true, false and nil are singleton instances of these classes.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">Plough => Ruby</a>
          <small>Journey through ruby</small>
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">Immediate Values</h1>
  <time datetime="2009-10-31T00:00:00+00:00" class="post-date">31 Oct 2009</time>
  <p>In a <a href="http://www.ploughthroughruby.co.uk/2009/08/is-variable-an-object/">previous post</a>, I have explained that variables are basically passed by values in ruby but since they have a reference to the original object any mutator methods can bascially modify the object itself. However, there are two exceptions to this; Fixnum and Symbol.</p>

<p>Both, Fixnum and Symbol, store the values and have no reference to the object. This also applies that there are no mutator methods for Fixnum and Symbol and they are immutable. So, how can we actually prove this fact. Let us do a simple experiment and I think I might have done this before but I do not want you going back and forth between posts so let us just do it again. Run the code snippet and we are going through each step:</p>

<pre>
  fixnum_1 = 3
  p fixnum_1.object_id
  fixnum_2 = 3
  p fixnum_2.object_id
  str_1 = "3"
  p str_1.object_id
  str_2 = "3"
  p str_2.object_id
</pre>

<p>You will see that both the fixnum variables have the same object_id where as with str variables they will be different. So, what does that mean? It simply means that two fixnums of same value always represent the same object instance, so instance variables for Fixnum with value 1 are shared across the system. The same is the case with Symbol.</p>

<p>Ok. Fine. This makes perfect sense but why should I bother with all this explanation. Well, that is a million dollar question really and the answer to that is “You can’t define singleton methods on Fixnums and Symbols”. What? Why? I know this is confusing but when in doubt think of an example.</p>

<p>We previously established that all the fixnum variables with same value are actually pointing to the same object instance. If let us say I want to define a singleton method on one then it would really define the singleton method on that object instance which means all the fixnum variables with same value would really share that new method you have added. Therefore, in order to cut that possibilty out one cannot define singleton methods on Fixnum, and Symbls.</p>

<p>Update: I have just realised that true (TrueClass), false (FalseClass) and nil (NilClass) also store the references as immediate values. And, yes there is a TrueClass, FalseClass and NilClass and true, false and nil are singleton instances of these classes.</p>

</article>


<aside class="related">
  <h3>Related posts</h3>
  <ul class="related-posts">
    
      <li>
        <a href="/2019/09/27/yarn-install-on-mojave/">
          Yarn Install On Mojave
          <small><time datetime="2019-09-27T00:00:00+01:00">27 Sep 2019</time></small>
        </a>
      </li>
    
      <li>
        <a href="/2019/09/27/installing-ffi-1.11.1-on-mojave/">
          Installing Ffi 1.11.1 On Mojave
          <small><time datetime="2019-09-27T00:00:00+01:00">27 Sep 2019</time></small>
        </a>
      </li>
    
      <li>
        <a href="/2016/10/06/dont-blindly-follow-blog-posts/">
          Dont Blindly Follow Blog Posts
          <small><time datetime="2016-10-06T00:00:00+01:00">06 Oct 2016</time></small>
        </a>
      </li>
    
  </ul>
</aside>


      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2021-07-03T06:18:22+01:00">2021</time>. All rights reserved.
        </small>
      </footer>
    </div>

    
  </body>
</html>
